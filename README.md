# Resources for correct stack unwinding

Most developers working on bare-metal software projects have probably seen a stack trace like
this one:

```
 #0  0x00007f14a1119081 in foo () from library.so
 #1  0x00007f14a13df640 in ?? () from totally_unrelated_library.so
 #2  0x00007f14a0e0c700 in ?? ()
 #3  0x0000000000000000 in ?? ()
```

which is obviously not the actual backtrace of the system. Unfortunately, this situation is
all-to-well accepted in the community, even though there is absolutely *no* reason to not have
accurate stack traces at every single instruction in a program. Even worse this attitude leads
to even more complication that could easily be avoided:

- Authors of language VMs, etc. that need to reliably unwind the stack (e.g. for the purpose of garbage
  collection) generally come up with their own scheme, one the one hand duplicating effort, but on the
  other making it quite impossible (or low performant) to use multiple such systems in the same process.
- Authors of debuggers have added a large number of heuristics to detect cases of incorrect unwind info
  and attempt to still give a somewhat accurate stack trace. These heuristics are also used when unwind
  info is not present at all. Unfortunately, even if the unwind info is correct, but the function is
  somewhat strange, these heuristics override the unwind info, causing incorrect stack traces.
- In many systems, unwinders are allowed to crash, causing simply a truncated stack trace. This is
  necesary because of invalid unwind info. However, it also masks bugs and crashes in the unwinder,
  generally degrading the quality of the obtained information.

This repository is a collection of resources and patches for creating executables where the unwind info
is indeed correct at every instruction. My primary use case for this is validation of unwind libraries
and compilers generating unwind info, but hopefully some of this effort may eventually be incorporated
in the relevant projects such that in the distant future all executables will have accurate unwind info.

The rest of this README is origanized as follows:
- An incomplete list of features that make use of unwind info
- A brief overview of how unwinders work
- A list and description of the resources and patches in this repository

# Features that use unwind info

For each, I will indicate whether unwind info is required at call sites only,
or at every instruction and whether they need to restore all registers, or only the instruction pointer.
Please feel free to submit additions to this list:
- Backtraces for debugging (All registers, every instruction)
- Exception handling (Only ips and generally only callsites, unless exceptions are generated by asynchronous events
  such as signals)
- Profiling (Every instruction, most profiliers only care about ips)
- Stack-scanning GCs (only ips and only callsites generally, but some implementations have stronger requirements)

# A brief introduction to unwinders

The following is a brief overview of unwinding on `x86_64/Linux`. Some other architectures are simpler
(e.g. have ABI-defined registers for callchains), though a lot of the information here applies generally.

## rbp based unwinding

Our story begins with frame-pointer based unwinding. `x86_64` has the rbp register which was intended to contain
the frame pointer and can be used for unwinding. To see how this works, consider the following assembly code
which shows the standard epilogue/prologue of an `x86_64` function:

```
pushq %rbp
movq %rsp, %rbp
[function body]
popq %rbp
ret
```

The one additional piece of information we need here is that function calls will push the return address onto
the stack before going to the called function. Thus upon entry to `[function body]` our stack looks like this
(stacks grow down):

```
+------------------+
|    Older RIP     |
+------------------+
|    Older RBP     <----+
+------------------+    |
|                  |    |
| Stack space      |    |
| used by previous |    |
⋮ function, e.g.   ⋮    |
⋮ local variables  ⋮    |
⋮ and other saved  ⋮    |
| resigers         |    |
|                  |    |
|                  |    |
+------------------+    |
|     Old RIP      |    |
+------------------+    |
|     Old RBP      +----+
+------------------+  <----- current RBP, RSP 
```

Note that while `rsp` will change throughout the life of the function, rbp will remain at its current location
while in this function. The end of the callchain is indicated by `rbp` being `0`. As such the unwind algorithm
is incredibly simple:

```julia
ips = Ptr{Void}[get_reg(regs, :rip)]
rbp = get_reg(regs, :rbp)
while rbp != 0
    push!(ips, load(rbp+sizeof(Ptr{Void})))
    rbp = load(rbp)
end
```

It should be noted that there is one small corner case in this algorithm. For the first and second instruction
of the prologue, this algorithm will skip the previous frame (because the rbp has not yet been switched over).
Unwinders will generally avoid this problem by looking at the next instruction and compensating if it looks
like the standard prologue instructions.

Unfortunately, for all its simplicitly there are two major problems with this approach:
- It doesn't restore non-ip registers (other than rbp), so it is not suited for all applications
- Some low-level functions may not be able to use the standard prologue
- It takes up the rbp registers, which is just another general-purpose register. As a result, there is
  a compiler option (`-fomit-frame-pointer`), that stops using `rbp` for unwinding and instead uses it
  as a general purpose register. As a result, if this option is enabled, frame-pointer based unwindning
  cannot be used at all in the executable. It should be noted however, that the advantage of using rbp
  as a general purpose register are not entirely clear, since most code does just fine with the number
  of general purpose registers avaialable (though this is not true on 32bit x86).

## DWARF based unwinding

With the stage set, we can now introduce the protagonist: DWARF-based unwinding. It solves major problems:
- It can provide accurate unwind info at every position in the function
- It can provide information for how to unwind non-ip registers
- It is entirely out-of-band and does not require any registers

However, it is significantly more complicated, in particular requiring:
- Knowledge of the object files, the ability to parse them and to locate them in the address space.
- A complete implementation of two separate state machines, one of them turning complete. Even the most
  compact implementation of these will require a few hundred lines of code, with several implementations
  significantly longer.
- Significantly more time. DWARF-based unwind can end up being quite slow.
- Hand-written unwind directives for any assembly code (which can get quite complicated)

As a result of this, there have been significant bugs on both the unwind data side and the unwinder side,
causing the problems mentioned in the introduction to this document. However, it deserved re-emphasizing
that there is *no* fundamental reason for this. As long as the register values exist somewhere in memory,
there probably exists an unwind info description that allows successful recovery of these registers.

### Locating unwind info
As mentioned, DWARF-based unwinding requires knowledge of which object file the current instruction belongs
to. This is in stark contrast, to the frame-pointer based unwinding discussed above. In particular, it makes
JIT and other ad-hoc creating of executable code significantly harder, since all such additions need to be
coordinated with the unwinder. For code located in libraries, the unwinder usually coordinates with the dynamic
library loader, either through API calls exposed by the dynamic loader (if in-process) or through the debugger
rendevouz mechanism (both of these are outside the scope of this document, but Gallium includes [an implementation](https://github.com/Keno/Gallium.jl/blob/master/src/modules.jl) of these techniques for all operating systems it supports.
It should be noted that unwind info in such libraries usually makes use of unrelocated addresses. Unwinders
must thus map between such addresses and virtual addresses in the process's address space. For shared libraries
this is generally done, but comparing the run-time library base (which can be obtained from the dynamic loader),
with the unrelocated base address of the first allocatable module (though the details vary by operating system
and object file format).

### The unwind algorithm
To perform an unwind step (i.e. map from the current set of registers to the next one), the following steps need
to be performed (for the actual implementation, see [here](https://github.com/Keno/Gallium.jl/blob/master/src/unwind.jl)):
- Determine which module (i.e. library, JITted code, etc) the current ip is located in and
  find the corresponding .eh_frame or .debug_frame section.
- Search through all FDEs in said section for the one that contains the current ip
- Execute the unwind program from the start of the FDE, until the current ip, recoding
  resolutions for all registers along the way (the format of this unwind program is described by the
  DWARF standard).
- Compute the canonical frame address (how to do so is determined by the unwind program)
- Iterate over all resolutions and perform the actual unwind. Each resolution, will compute the
  register value of some register in the previous frame as a function of (registers, memory, cfa address).
  In general most resolution will be simple and special cased, but there is a full stack-based VM that
  allows the expression of arbitrary functions of the input parameters. Again the details are described
  in the DWARF standard.

# Patches for correct unwinding

For details, I recommend reading the commit messages for these patches, what follows is only a brief overview.
For glibc:
- `0001-Add-CFI-to-x86_64-RTLD_START.patch` - Adds unwind info to `_start` assembly function`
- `0001-x86_64-Expand-CFI-to-cover-clone-after-the-syscall.patch` - Fixes unwind info for `clone`
- `0001-Hack-in-startup-code-to-force-.init_array-use.patch` - Removes support for .init, using .init_array instead
  (Note to creators of the new linux distributions - consider dropping support for .init from your distribution).

For binutils:
- `0001-Fix-unwind-info-for-.plt.got-section.patch` - Fixes https://sourceware.org/bugzilla/show_bug.cgi?id=20830

